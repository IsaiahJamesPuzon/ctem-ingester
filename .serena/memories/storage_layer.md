# Storage Layer

## Database Tables (SQLAlchemy ORM)

### 1. exposure_events (Append-Only Audit Log)
**Table**: `src/models/storage.py` - `ExposureEvent` class
- **Primary key**: `event_id` (String, UUID from canonical event)
- **Purpose**: Time series audit trail - "what changed when?"
- **Key columns**: event_id, timestamp, office_id, asset_id, exposure_id, exposure_class, exposure_status, event_action, severity, dst_ip, dst_port, protocol, service_json, raw_payload_json
- **Indexes**: 
  - (office_id, timestamp)
  - (asset_id, timestamp)
  - (exposure_class, exposure_status)
  - scan_run_id
  - dedupe_key
- **Data retention**: Never deleted, grows indefinitely

### 2. exposures_current (Upserted Latest State)
**Table**: `src/models/storage.py` - `ExposureCurrent` class
- **Primary key**: `id` (String, UUID - auto-generated by application)
- **Unique key**: `(office_id, exposure_id)`
- **Purpose**: Fast queries for current exposure state, Metabase dashboards
- **Key columns**: id, office_id, exposure_id, exposure_class, status, dst_ip, dst_port, protocol, transport, severity, risk_score, first_seen, last_seen, asset_*, service_*, resource_json, disposition_*
- **Indexes**: 
  - (office_id, exposure_class)
  - (status, severity)
  - asset_id
  - last_seen
- **Upsert behavior**: Manual upsert (find-or-create pattern)

### 3. quarantined_files (Dead-Letter Queue)
**Table**: `src/models/storage.py` - `QuarantinedFile` class
- **Primary key**: `id` (String, UUID - auto-generated by application)
- **Purpose**: Track files that failed processing with error details
- **Key columns**: id, filename, file_size, file_hash, error_type, error_message, error_details_json, scanner_type, office_id, quarantined_at
- **Indexes**: 
  - quarantined_at
  - error_type

## Database Configuration

### DuckDB Settings (src/storage/database.py)
- **Connection**: Uses SQLAlchemy with duckdb-engine dialect
- **Default path**: `./data/exposures.duckdb` (local) or `/app/data/exposures.duckdb` (Docker)
- **Type compiler**: Custom INTEGER compiler to avoid SERIAL generation
- **Auto-creation**: Parent directories created automatically
- **Primary keys**: String-based (UUID) to avoid auto-increment issues

### Connection Management (src/storage/connection.py)
- **DatabaseManager**: Singleton pattern for engine/session management
- **Connection pooling**: StaticPool for DuckDB (single-writer constraint)
- **Session factory**: Thread-safe session creation
- **Context manager**: `get_db_session()` for automatic commit/rollback

## Upsert Logic (src/storage/repository.py)

### Critical Rules
1. **Preserve first_seen**: NEVER overwrite first_seen on update
2. **Update last_seen**: ALWAYS update last_seen to latest observation
3. **Null preservation**: Optional fields with existing non-null values are NOT overwritten by null
4. **Always update**: status, severity, event_action, event_kind, updated_at
5. **Conditionally update**: risk_score, confidence, service_*, resource_*, asset_*, disposition_*
6. **ID generation**: New records get auto-generated UUID for primary key

### Batch Processing
- **Function**: `batch_ingest_exposures(events)` in ExposureRepository
- **Method**: Manual upsert using find-or-create pattern
- **Chunk size**: 500 events per transaction (optimal for DuckDB)
- **Returns**: Dict with inserted/updated counts and processing time
- **Transaction**: Automatic commit on success, rollback on error

### Implementation Details
- Uses manual upsert (not native ON CONFLICT) for maximum compatibility
- Queries by (office_id, exposure_id) to find existing records
- Generates UUID for new exposures' primary key field
- Preserves non-null values when updating optional fields
